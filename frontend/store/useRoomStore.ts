import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { WebSocketClient, ChatPayload, ClientInfo } from '@/lib/websockets';
import { WebRTCManager } from '@/lib/webrtc';

/**
 * SOCIAL MEDIA VIDEO CONFERENCE STORE
 * 
 * This is the central state management system for the real-time video conferencing application.
 * Built with Zustand for lightweight, efficient state management with Redux DevTools integration.
 * 
 * Key Features:
 * - Real-time WebSocket communication with Go backend
 * - WebRTC peer-to-peer media streaming
 * - Role-based participant management (Host, Moderator, Participant)
 * - Persistent chat with unread tracking
 * - Waiting room functionality for security
 * - Device switching and media controls
 * - Screen sharing capabilities
 * - Connection state monitoring and auto-reconnection
 * 
 * Architecture:
 * Frontend (React/Next.js) ↔ WebSocket ↔ Go Backend ↔ WebRTC Peers
 */

// =================== TYPE DEFINITIONS ===================

/**
 * Represents a participant in the video conference room
 * 
 * This interface tracks all participant state including their media settings,
 * role permissions, and current activity status. Each participant has a unique
 * ID and maintains their own media stream.
 */
export interface Participant {
  id: string;                    // Unique identifier for this participant (generated by backend)
  username: string;              // Display name shown to other participants
  role: 'host' | 'moderator' | 'participant';  // Permission level determining available actions
  isAudioEnabled: boolean;       // Whether their microphone is active and audible
  isVideoEnabled: boolean;       // Whether their camera is on and visible
  isScreenSharing: boolean;      // Whether they're currently sharing their screen
  isSpeaking: boolean;           // Voice activity detection - whether currently speaking
  lastActivity: Date;            // Last interaction timestamp (for timeout/away detection)
  stream?: MediaStream;          // Their WebRTC media stream (audio/video data)
}

/**
 * Represents a chat message in the room
 * 
 * Supports different message types including public chat, private messages,
 * and system notifications. Messages are stored chronologically and persist
 * for the duration of the room session.
 */
export interface ChatMessage {
  id: string;                    // Unique message identifier (prevents duplicates)
  participantId: string;         // ID of the message sender
  username: string;              // Display name of sender (for UI rendering)
  content: string;               // The actual message text content
  timestamp: Date;               // When the message was sent (for chronological ordering)
  type: 'text' | 'system' | 'private';  // Message type for styling and filtering
  targetId?: string;             // For private messages: recipient's participant ID
}

/**
 * Room configuration settings that control participant capabilities
 * 
 * These settings are typically managed by room hosts/moderators and determine
 * what actions participants can perform. Changes are broadcast to all participants.
 */
export interface RoomSettings {
  allowScreenShare: boolean;     // Whether participants can initiate screen sharing
  allowChat: boolean;            // Whether the chat feature is enabled
  allowParticipantAudio: boolean; // Whether participants can unmute themselves
  allowParticipantVideo: boolean; // Whether participants can enable their camera
  maxParticipants: number;       // Maximum number of concurrent participants
  requireApproval: boolean;      // Whether host approval is required to join
}

/**
 * Connection state tracking for real-time components
 * 
 * Monitors the health of WebSocket and WebRTC connections, providing
 * status indicators for the UI and enabling automatic reconnection logic.
 */
export interface ConnectionState {
  wsConnected: boolean;          // WebSocket connection status to Go backend
  wsReconnecting: boolean;       // Whether WebSocket is attempting to reconnect
  webrtcConnected: boolean;      // WebRTC peer connection status for media streaming
  lastError?: string;            // Most recent error message for user display
}

// =================== MAIN STATE INTERFACE ===================

/**
 * Complete state interface for the room store
 * 
 * Organized into logical sections for maintainability:
 * - Room metadata and settings
 * - Participant management
 * - Media streams and device controls
 * - Chat system
 * - UI state management
 * - Connection monitoring
 * - Client instances
 */
interface RoomState {
  // =================== ROOM METADATA ===================
  roomId: string | null;                    // Unique room identifier from backend
  roomName: string | null;                  // Human-readable room name
  roomSettings: RoomSettings | null;        // Room configuration and permissions
  isJoined: boolean;                        // Whether user has successfully joined
  isHost: boolean;                          // Whether current user has host privileges
  currentUserId: string | null;             // Current user's unique identifier
  currentUsername: string | null;           // Current user's display name

  // =================== PARTICIPANT MANAGEMENT ===================
  participants: Map<string, Participant>;   // All active participants indexed by ID
  localParticipant: Participant | null;     // Current user's participant data
  speakingParticipants: Set<string>;        // IDs of participants currently speaking

  // =================== MEDIA STREAMS AND DEVICES ===================
  localStream: MediaStream | null;          // User's camera/microphone stream
  screenShareStream: MediaStream | null;    // User's screen sharing stream
  isAudioEnabled: boolean;                  // Current microphone state
  isVideoEnabled: boolean;                  // Current camera state
  isScreenSharing: boolean;                 // Current screen sharing state
  
  // Available media devices (populated from browser MediaDevices API)
  availableDevices: {
    cameras: MediaDeviceInfo[];             // Available camera devices
    microphones: MediaDeviceInfo[];         // Available microphone devices
    speakers: MediaDeviceInfo[];            // Available speaker/output devices
  };
  
  // Currently selected devices for media capture
  selectedDevices: {
    camera?: string;                        // Selected camera device ID
    microphone?: string;                    // Selected microphone device ID
    speaker?: string;                       // Selected speaker device ID
  };

  // =================== CHAT SYSTEM ===================
  messages: ChatMessage[];                  // Complete chat history in chronological order
  unreadCount: number;                      // Number of unread messages for badge display
  isChatPanelOpen: boolean;                // Chat panel visibility state

  // =================== UI STATE MANAGEMENT ===================
  isParticipantsPanelOpen: boolean;        // Participants list panel visibility
  isWaitingRoom: boolean;                  // Whether user is in waiting room awaiting approval
  pendingParticipants: Participant[];      // Participants awaiting host approval
  selectedParticipantId: string | null;    // Currently selected participant for actions
  gridLayout: 'gallery' | 'speaker' | 'sidebar';  // Video layout configuration
  isPinned: boolean;                       // Whether any participant is pinned
  pinnedParticipantId: string | null;      // ID of currently pinned participant

  // =================== CONNECTION MONITORING ===================
  connectionState: ConnectionState;        // Real-time connection health status
  
  // =================== CLIENT INSTANCES ===================
  wsClient: WebSocketClient | null;        // WebSocket client for real-time communication
  webrtcManager: WebRTCManager | null;     // WebRTC manager for peer-to-peer media
  clientInfo: ClientInfo | null;           // Current user's client identification
}

// =================== ACTIONS INTERFACE ===================

/**
 * All available actions that can be performed on the room store
 * 
 * Actions are organized by functional area for better code organization
 * and to make it easier to understand what operations are available.
 * Each action is designed to be atomic and handle its own error cases.
 */
interface RoomActions {
  // =================== ROOM LIFECYCLE MANAGEMENT ===================
  initializeRoom: (roomId: string, username: string, token: string) => Promise<void>;  // Set up connections and join room
  joinRoom: (approvalToken?: string) => Promise<void>;                                // Request to join room (may require approval)
  leaveRoom: () => void;                                                              // Clean up and exit room
  updateRoomSettings: (settings: Partial<RoomSettings>) => void;                     // Modify room configuration (host only)

  // =================== PARTICIPANT MANAGEMENT ===================
  addParticipant: (participant: Participant) => void;                                // Add new participant to room
  removeParticipant: (participantId: string) => void;                               // Remove participant and clean up UI state
  updateParticipant: (participantId: string, updates: Partial<Participant>) => void; // Update participant properties
  approveParticipant: (participantId: string) => void;                              // Approve waiting room participant (host only)
  kickParticipant: (participantId: string) => void;                                 // Remove participant from room (host only)
  toggleParticipantAudio: (participantId: string) => void;                          // Mute/unmute participant (host only)
  toggleParticipantVideo: (participantId: string) => void;                          // Enable/disable participant video (host only)

  // =================== LOCAL MEDIA CONTROLS ===================
  toggleAudio: () => Promise<void>;                      // Mute/unmute local microphone
  toggleVideo: () => Promise<void>;                      // Enable/disable local camera
  startScreenShare: () => Promise<void>;                 // Begin screen sharing
  stopScreenShare: () => Promise<void>;                  // End screen sharing
  switchCamera: (deviceId: string) => Promise<void>;     // Change to different camera device
  switchMicrophone: (deviceId: string) => Promise<void>; // Change to different microphone device
  refreshDevices: () => Promise<void>;                   // Update list of available media devices

  // =================== CHAT SYSTEM ===================
  sendMessage: (content: string, type?: 'text' | 'private', targetId?: string) => void; // Send chat message
  markMessagesRead: () => void;                                                          // Clear unread message count
  toggleChatPanel: () => void;                                                           // Show/hide chat panel

  // =================== UI STATE CONTROLS ===================
  toggleParticipantsPanel: () => void;                                        // Show/hide participants list
  setGridLayout: (layout: 'gallery' | 'speaker' | 'sidebar') => void;        // Change video layout mode
  pinParticipant: (participantId: string | null) => void;                    // Pin/unpin participant video
  selectParticipant: (participantId: string | null) => void;                 // Select participant for actions

  // =================== CONNECTION MANAGEMENT ===================
  updateConnectionState: (updates: Partial<ConnectionState>) => void;        // Update connection status indicators
  handleError: (error: string) => void;                                      // Display error message to user
  clearError: () => void;                                                    // Clear current error message
}

// =================== ZUSTAND STORE CREATION ===================

/**
 * MAIN ROOM STORE
 * 
 * This is the heart of the video conferencing application's state management.
 * Created using Zustand with Redux DevTools integration for debugging.
 * 
 * Key Design Principles:
 * - Single source of truth for all room-related state
 * - Immutable state updates to prevent bugs
 * - Clear separation between state and actions
 * - Comprehensive error handling and logging
 * - Automatic cleanup to prevent memory leaks
 * 
 * State Flow:
 * 1. User calls initializeRoom() with credentials
 * 2. WebSocket connection established to Go backend
 * 3. Event handlers set up for real-time communication
 * 4. WebRTC manager created for peer-to-peer media
 * 5. User calls joinRoom() to enter room (may go to waiting room)
 * 6. Backend sends room_state updates with participant info
 * 7. UI components subscribe to state changes and re-render
 * 8. User interactions trigger actions that update state
 * 9. State changes propagate to backend via WebSocket
 * 10. leaveRoom() cleans up all connections and resets state
 */
export const useRoomStore = create<RoomState & RoomActions>()(
  devtools(
    (set, get) => ({
      // =================== INITIAL STATE ===================
      // All state starts with safe default values that represent a disconnected state
      // Values will be populated during room initialization and joining process
      
      // Room metadata - initially empty until room is joined
      roomId: null,                          // No room selected
      roomName: null,                        // No room name available
      roomSettings: null,                    // No settings until host provides them
      isJoined: false,                       // User has not joined any room
      isHost: false,                         // User is not a host initially
      currentUserId: null,                   // No user ID until authentication
      currentUsername: null,                 // No username until provided

      // Participants - start with empty collections
      participants: new Map(),               // No participants until room is joined
      localParticipant: null,                // No local participant data yet
      speakingParticipants: new Set(),       // No one speaking initially

      // Media streams - initially null until user grants permissions
      localStream: null,                     // No media stream until camera/mic access
      screenShareStream: null,               // No screen sharing initially
      isAudioEnabled: true,                  // Default to audio enabled (user can mute)
      isVideoEnabled: true,                  // Default to video enabled (user can turn off)
      isScreenSharing: false,                // Not sharing screen by default
      
      // Available devices - will be populated by refreshDevices()
      availableDevices: {
        cameras: [],                         // No cameras detected yet
        microphones: [],                     // No microphones detected yet
        speakers: [],                        // No speakers detected yet
      },
      selectedDevices: {},                   // No devices selected initially

      // Chat system - start empty
      messages: [],                          // No chat messages yet
      unreadCount: 0,                        // No unread messages
      isChatPanelOpen: false,               // Chat panel closed by default

      // UI state - sensible defaults for user experience
      isParticipantsPanelOpen: false,       // Participants panel closed by default
      isWaitingRoom: false,                 // Not in waiting room initially
      pendingParticipants: [],              // No pending participants
      selectedParticipantId: null,          // No participant selected
      gridLayout: 'gallery',                // Default to gallery view showing all participants
      isPinned: false,                      // No participant pinned
      pinnedParticipantId: null,            // No pinned participant

      // Connection state - all disconnected initially
      connectionState: {
        wsConnected: false,                 // WebSocket not connected
        wsReconnecting: false,              // Not attempting to reconnect
        webrtcConnected: false,             // WebRTC not connected
      },

      // Client instances - will be created during initialization
      wsClient: null,                       // WebSocket client not created yet
      webrtcManager: null,                  // WebRTC manager not created yet
      clientInfo: null,                     // Client info not available yet

      // =================== ACTION IMPLEMENTATIONS ===================

      /**
       * INITIALIZE ROOM - Main entry point for joining a video conference
       * 
       * This is the most important action in the entire store. It sets up all the
       * necessary connections and event handlers for real-time communication.
       * 
       * Process Flow:
       * 1. Clean up any existing connections (prevents memory leaks)
       * 2. Generate unique client information for this session
       * 3. Create WebSocket connection to Go backend
       * 4. Set up comprehensive event handlers for all backend events
       * 5. Initialize WebRTC manager for peer-to-peer media streaming
       * 6. Enumerate available media devices
       * 7. Update store with all initialized components
       * 
       * @param roomId - Unique identifier for the room to join
       * @param username - Display name for this user
       * @param token - JWT authentication token for backend verification
       */
      initializeRoom: async (roomId: string, username: string, token: string) => {
        const state = get();
        
        console.log('🚀 Initializing room connection...', { roomId, username });
        
        // =================== CLEANUP EXISTING CONNECTIONS ===================
        // Clean up any existing connections to prevent memory leaks and connection conflicts
        if (state.wsClient) {
          console.log('🧹 Cleaning up existing WebSocket connection');
          state.wsClient.disconnect();
        }

        // =================== CLIENT IDENTIFICATION SETUP ===================
        // Create unique client information for this session
        // clientId includes timestamp and random string to ensure global uniqueness
        const clientInfo: ClientInfo = {
          clientId: `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          displayName: username,
        };

        console.log('👤 Created client info:', clientInfo);

        // =================== WEBSOCKET CONNECTION SETUP ===================
        // Create WebSocket client with production endpoint matching Go backend routes
        // This connects to the session handler in /backend/go/cmd/v1/session/
        const wsClient = new WebSocketClient({
          url: `ws://localhost:8080/ws/zoom/${roomId}`, // ✅ Matches Go backend route pattern
          token,                                        // JWT for Auth0 authentication
          autoReconnect: true,                         // Automatically reconnect if connection drops
          reconnectInterval: 3000,                     // Wait 3 seconds between reconnection attempts
          maxReconnectAttempts: 5,                     // Give up after 5 failed attempts
        });

        console.log('🔌 Created WebSocket client for room:', roomId);

        // =================== CHAT EVENT HANDLERS ===================
        
        /**
         * CHAT MESSAGE HANDLER
         * 
         * Processes incoming chat messages from other participants.
         * Updates the message list and unread count for UI notifications.
         */
        wsClient.on('add_chat', (message) => {
          console.log('💬 Received chat message:', message);
          const chatPayload = message.payload as ChatPayload;
          
          // Convert backend chat format to our internal message format
          const chatMessage: ChatMessage = {
            id: chatPayload.chatId,
            participantId: chatPayload.clientId,
            username: chatPayload.displayName,
            content: chatPayload.chatContent,
            timestamp: new Date(chatPayload.timestamp),
            type: 'text',
          };

          // Add to message list and update unread count if chat panel is closed
          set((state) => ({
            messages: [...state.messages, chatMessage],
            unreadCount: state.isChatPanelOpen ? state.unreadCount : state.unreadCount + 1,
          }));
        });

        // =================== ROOM STATE MANAGEMENT ===================
        
        /**
         * ROOM STATE HANDLER - CRITICAL FOR PARTICIPANT SYNCHRONIZATION
         * 
         * This is the most important event handler for maintaining consistent room state.
         * The Go backend sends this event whenever:
         * - A participant joins or leaves the room
         * - Host/moderator roles change
         * - Waiting room status changes
         * - Media sharing states change
         * 
         * The payload contains complete participant lists organized by role.
         */
        wsClient.on('room_state', (message) => {
          console.log('🏠 Received room state update:', message);
          const payload = message.payload as any; // RoomStatePayload from Go backend
          
          // =================== PARTICIPANTS MAP CONSTRUCTION ===================
          // Build new participants map from backend data
          const participantsMap = new Map<string, Participant>();
          
          // Process hosts (users with administrative privileges)
          payload.hosts?.forEach((host: any) => {
            participantsMap.set(host.clientId, {
              id: host.clientId,
              username: host.displayName,
              role: 'host',                      // Hosts can manage room and participants
              isAudioEnabled: true,              // Default to enabled - will be updated by media events
              isVideoEnabled: true,              // Default to enabled - will be updated by media events  
              isScreenSharing: false,            // Screen sharing status managed separately
              isSpeaking: false,                 // Voice activity detection managed separately
              lastActivity: new Date(),          // Mark as currently active
            });
          });

          // Process regular participants
          payload.participants?.forEach((participant: any) => {
            participantsMap.set(participant.clientId, {
              id: participant.clientId,
              username: participant.displayName,
              role: 'participant',               // Regular participants with standard permissions
              isAudioEnabled: true,              // Default to enabled
              isVideoEnabled: true,              // Default to enabled
              isScreenSharing: false,            // Screen sharing status managed separately
              isSpeaking: false,                 // Voice activity detection managed separately
              lastActivity: new Date(),          // Mark as currently active
            });
          });

          // =================== WAITING ROOM PROCESSING ===================
          // Handle participants awaiting host approval
          const waitingParticipants: Participant[] = payload.waitingUsers?.map((user: any) => ({
            id: user.clientId,
            username: user.displayName,
            role: 'participant' as const,
            isAudioEnabled: false,              // Waiting room users cannot use media yet
            isVideoEnabled: false,              // Waiting room users cannot use media yet
            isScreenSharing: false,
            isSpeaking: false,
            lastActivity: new Date(),
          })) || [];

          console.log('👥 Updated participants:', {
            active: participantsMap.size,
            waiting: waitingParticipants.length,
            isCurrentUserHost: payload.hosts?.some((h: any) => h.clientId === clientInfo.clientId)
          });

          // =================== STATE UPDATE ===================
          // Update store with new participant data and host status
          set({
            participants: participantsMap,
            pendingParticipants: waitingParticipants,
            // Check if current user is in the hosts list
            isHost: payload.hosts?.some((h: any) => h.clientId === clientInfo.clientId) || false,
          });
        });

        // =================== WAITING ROOM EVENT HANDLERS ===================
        
        /**
         * WAITING ROOM APPROVAL HANDLER
         * 
         * Called when the host approves this user to join the main room.
         * Transitions user from waiting room to active participant status.
         */
        wsClient.on('accept_waiting', (message) => {
          console.log('✅ Approved to join room');
          set({ isWaitingRoom: false, isJoined: true });
        });

        /**
         * WAITING ROOM DENIAL HANDLER
         * 
         * Called when the host denies this user access to the room.
         * Displays error message and prevents further join attempts.
         */
        wsClient.on('deny_waiting', (message) => {
          console.log('❌ Denied access to room');
          get().handleError('Access to room denied by host');
        });

        // =================== HAND RAISING EVENT HANDLERS ===================
        
        /**
         * RAISE HAND HANDLER
         * 
         * Processes when a participant raises their hand to request speaking permission.
         * Adds them to the speaking participants set for UI indication (hand icon, etc).
         */
        wsClient.on('raise_hand', (message) => {
          console.log('✋ Participant raised hand:', message);
          const payload = message.payload as any;
          
          // Add to speaking participants set for UI indication
          set((state) => {
            const newSpeaking = new Set(state.speakingParticipants);
            newSpeaking.add(payload.clientId);
            return { speakingParticipants: newSpeaking };
          });
        });

        /**
         * LOWER HAND HANDLER
         * 
         * Processes when a participant lowers their hand (no longer requesting to speak).
         * Removes them from speaking participants set to clear UI indication.
         */
        wsClient.on('lower_hand', (message) => {
          console.log('👋 Participant lowered hand:', message);
          const payload = message.payload as any;
          
          // Remove from speaking participants set
          set((state) => {
            const newSpeaking = new Set(state.speakingParticipants);
            newSpeaking.delete(payload.clientId);
            return { speakingParticipants: newSpeaking };
          });
        });

        // =================== WEBRTC SIGNALING EVENT HANDLERS ===================
        // These handlers manage the WebRTC peer-to-peer connection setup process
        // WebRTC requires a "signaling" process to establish direct connections between browsers
        
        /**
         * WEBRTC OFFER HANDLER
         * 
         * Handles incoming WebRTC connection offers from other participants.
         * An "offer" contains media capabilities and connection information.
         * The WebRTCManager will process this and generate an "answer".
         */
        wsClient.on('offer', (message) => {
          console.log('📡 Received WebRTC offer:', message);
          if (get().webrtcManager) {
            // WebRTCManager handles the technical details of offer processing
            // This includes creating an answer and setting up the peer connection
            console.log('🔄 Forwarding offer to WebRTC manager for processing');
            // TODO: Call webrtcManager.handleOffer(message) when WebRTCManager is implemented
          }
        });

        /**
         * WEBRTC ANSWER HANDLER
         * 
         * Handles incoming WebRTC connection answers in response to our offers.
         * An "answer" confirms the other peer's media capabilities and completes connection setup.
         */
        wsClient.on('answer', (message) => {
          console.log('📡 Received WebRTC answer:', message);
          if (get().webrtcManager) {
            // WebRTCManager will complete the connection establishment
            console.log('🔄 Forwarding answer to WebRTC manager for processing');
            // TODO: Call webrtcManager.handleAnswer(message) when WebRTCManager is implemented
          }
        });

        /**
         * ICE CANDIDATE HANDLER
         * 
         * Handles ICE (Interactive Connectivity Establishment) candidates.
         * ICE candidates contain network path information to establish the most
         * efficient route for media streaming between peers.
         */
        wsClient.on('candidate', (message) => {
          console.log('🧊 Received ICE candidate:', message);
          if (get().webrtcManager) {
            // ICE candidates help establish the optimal network path for media streaming
            console.log('🔄 Forwarding ICE candidate to WebRTC manager');
            // TODO: Call webrtcManager.handleCandidate(message) when WebRTCManager is implemented
          }
        });

        // =================== CONNECTION STATE MONITORING ===================
        
        /**
         * CONNECTION CHANGE HANDLER
         * 
         * Monitors WebSocket connection state changes and updates UI accordingly.
         * Provides real-time feedback to users about their connection status.
         */
        wsClient.onConnectionChange?.((connectionState: string) => {
          console.log('🔗 WebSocket connection state changed:', connectionState);
          
          // Update connection state for UI indicators (online/offline badges, etc)
          set((state) => ({
            connectionState: {
              ...state.connectionState,
              wsConnected: connectionState === 'connected',
              wsReconnecting: connectionState === 'reconnecting',
            }
          }));
        });

        /**
         * ERROR HANDLER
         * 
         * Captures and displays WebSocket communication errors.
         * Provides user-friendly error messages for connection issues.
         */
        wsClient.onError((error: Error) => {
          console.error('❌ WebSocket error:', error);
          get().handleError(`Connection error: ${error.message}`);
        });

        // =================== CONNECTION ESTABLISHMENT ===================
        
        try {
          console.log('🔌 Establishing WebSocket connection...');
          // Connect to the Go backend WebSocket endpoint
          await wsClient.connect();
          console.log('✅ WebSocket connected successfully');

          // =================== WEBRTC MANAGER INITIALIZATION ===================
          // Create WebRTC manager for peer-to-peer media streaming between participants
          console.log('🎥 Initializing WebRTC manager...');
          const webrtcManager = new WebRTCManager(clientInfo, wsClient);

          // =================== CONNECTION STATE UPDATE ===================
          // Update UI to reflect successful WebSocket connection
          set((state) => ({
            connectionState: { ...state.connectionState, wsConnected: true }
          }));

          // =================== DEVICE ENUMERATION ===================
          // Get list of available cameras, microphones, and speakers
          console.log('🎤 Refreshing available media devices...');
          await get().refreshDevices();

          // =================== FINAL STATE UPDATE ===================
          // Store all initialized components in the state
          set({
            roomId,                    // Store room identifier
            currentUsername: username, // Store user's display name
            wsClient,                  // Store WebSocket client for later use
            webrtcManager,             // Store WebRTC manager for media operations
            clientInfo,                // Store client identification info
          });

          console.log('🎉 Room initialization completed successfully');
          
        } catch (error) {
          console.error('💥 Failed to initialize room:', error);
          get().handleError(`Failed to initialize room: ${error}`);
          throw error; // Re-throw so caller can handle it
        }
      },

      /**
       * JOIN ROOM - Request to join the initialized room
       * 
       * After initializing the room connection, this action attempts to join the actual room.
       * Depending on room settings, the user may be placed in a waiting room for host approval.
       * 
       * @param approvalToken - Optional pre-approval token if user was invited
       */
      joinRoom: async (approvalToken?: string) => {
        const { wsClient, clientInfo } = get();
        
        // Validate that we have the necessary connections
        if (!wsClient || !clientInfo) {
          console.error('❌ Cannot join room: WebSocket or client info not available');
          get().handleError('Connection not ready. Please try again.');
          return;
        }

        try {
          console.log('🚪 Requesting to join room...');
          
          // Send join request to backend via WebSocket
          // This uses the existing requestWaiting method which may place user in waiting room
          wsClient.requestWaiting(clientInfo);
          
          // Optimistically update state - backend will send room_state events to correct if needed
          set({ isJoined: true, isWaitingRoom: false });
          
          console.log('📤 Join room request sent successfully');
          
        } catch (error) {
          console.error('💥 Failed to join room:', error);
          get().handleError(`Failed to join room: ${error}`);
        }
      },

      /**
       * LEAVE ROOM - Clean exit from room with full cleanup
       * 
       * This is critical for preventing memory leaks and ensuring clean disconnection.
       * It stops all media streams, closes peer connections, disconnects WebSocket,
       * and resets the entire state to initial values.
       */
      leaveRoom: () => {
        console.log('👋 Leaving room and performing cleanup...');
        
        const { wsClient, webrtcManager, localStream, screenShareStream } = get();
        
        // =================== MEDIA STREAM CLEANUP ===================
        // Stop all media streams to release camera/microphone hardware
        if (localStream) {
          console.log('📹 Stopping local media stream');
          localStream.getTracks().forEach(track => {
            track.stop(); // This releases the camera/microphone
            console.log(`🛑 Stopped ${track.kind} track`);
          });
        }
        
        if (screenShareStream) {
          console.log('🖥️ Stopping screen share stream');
          screenShareStream.getTracks().forEach(track => {
            track.stop(); // This stops screen sharing
            console.log(`🛑 Stopped screen share ${track.kind} track`);
          });
        }

        // =================== WEBRTC CLEANUP ===================
        // Clean up all peer connections and WebRTC resources
        if (webrtcManager) {
          console.log('🔗 Cleaning up WebRTC connections');
          webrtcManager.cleanup();
        }

        // =================== WEBSOCKET CLEANUP ===================
        // Disconnect from backend and stop receiving events
        if (wsClient) {
          console.log('🔌 Disconnecting WebSocket');
          wsClient.disconnect();
        }

        // =================== STATE RESET ===================
        // Reset entire state to initial values to prevent stale data
        set({
          // Room metadata
          roomId: null,
          roomName: null,
          roomSettings: null,
          isJoined: false,
          isHost: false,
          currentUserId: null,
          currentUsername: null,
          
          // Participants
          participants: new Map(),
          localParticipant: null,
          speakingParticipants: new Set(),
          
          // Media
          localStream: null,
          screenShareStream: null,
          isAudioEnabled: true,
          isVideoEnabled: true,
          isScreenSharing: false,
          
          // Chat
          messages: [],
          unreadCount: 0,
          isChatPanelOpen: false,
          
          // UI
          isParticipantsPanelOpen: false,
          isWaitingRoom: false,
          pendingParticipants: [],
          selectedParticipantId: null,
          gridLayout: 'gallery',
          isPinned: false,
          pinnedParticipantId: null,
          
          // Connections
          connectionState: {
            wsConnected: false,
            wsReconnecting: false,
            webrtcConnected: false,
          },
          wsClient: null,
          webrtcManager: null,
          clientInfo: null,
        });

        console.log('✅ Room cleanup completed successfully');
      },

      // =================== ROOM SETTINGS MANAGEMENT ===================
      
      /**
       * UPDATE ROOM SETTINGS - Modify room configuration (host only)
       * 
       * Updates room-wide settings that control participant capabilities.
       * In a full implementation, this would validate host permissions
       * and broadcast changes to all participants via WebSocket.
       */
      updateRoomSettings: (settings: Partial<RoomSettings>) => {
        console.log('⚙️ Updating room settings:', settings);
        
        // For now, just update local state
        // TODO: Send settings update to backend when room management API is implemented
        set((state) => ({
          roomSettings: { ...state.roomSettings, ...settings } as RoomSettings
        }));
      },

      // =================== PARTICIPANT MANAGEMENT ===================
      
      /**
       * ADD PARTICIPANT - Add new participant to room
       * 
       * Typically called by event handlers when backend notifies of new participants.
       * Updates the participants map and triggers UI re-renders.
       */
      addParticipant: (participant: Participant) => {
        console.log('👤 Adding participant:', participant.username, participant.id);
        
        set((state) => {
          const newParticipants = new Map(state.participants);
          newParticipants.set(participant.id, participant);
          return { participants: newParticipants };
        });
      },

      /**
       * REMOVE PARTICIPANT - Remove participant and clean up UI state
       * 
       * Removes participant from all relevant state collections and clears
       * any UI selections or pinning related to that participant.
       */
      removeParticipant: (participantId: string) => {
        console.log('👤 Removing participant:', participantId);
        
        set((state) => {
          // Remove from participants map
          const newParticipants = new Map(state.participants);
          newParticipants.delete(participantId);
          
          // Remove from speaking participants
          const newSpeaking = new Set(state.speakingParticipants);
          newSpeaking.delete(participantId);

          return {
            participants: newParticipants,
            speakingParticipants: newSpeaking,
            // Clear selection/pinning if this participant was selected
            selectedParticipantId: state.selectedParticipantId === participantId ? null : state.selectedParticipantId,
            pinnedParticipantId: state.pinnedParticipantId === participantId ? null : state.pinnedParticipantId,
          };
        });
      },

      /**
       * UPDATE PARTICIPANT - Modify participant properties
       * 
       * Updates specific fields of a participant (e.g., mute status, video status).
       * Used for real-time updates of participant state from backend events.
       */
      updateParticipant: (participantId: string, updates: Partial<Participant>) => {
        console.log('👤 Updating participant:', participantId, updates);
        
        set((state) => {
          const newParticipants = new Map(state.participants);
          const existing = newParticipants.get(participantId);
          
          if (existing) {
            // Merge updates with existing participant data
            newParticipants.set(participantId, { ...existing, ...updates });
          } else {
            console.warn('⚠️ Attempted to update non-existent participant:', participantId);
          }
          
          return { participants: newParticipants };
        });
      },

      /**
       * APPROVE PARTICIPANT - Move participant from waiting room to main room (host only)
       * 
       * Approves a participant awaiting host approval to join the main room.
       * In full implementation, this would send approval command to backend.
       */
      approveParticipant: (participantId: string) => {
        console.log('✅ Approving participant:', participantId);
        
        // Remove from pending list (backend will send room_state update with full participants)
        set((state) => ({
          pendingParticipants: state.pendingParticipants.filter(p => p.id !== participantId)
        }));
        
        // TODO: Send approval command to backend via WebSocket
      },

      /**
       * KICK PARTICIPANT - Remove participant from room (host only)
       * 
       * Forcibly removes a participant from the room.
       * In full implementation, this would send kick command to backend.
       */
      kickParticipant: (participantId: string) => {
        console.log('❌ Kicking participant:', participantId);
        
        // Remove participant immediately from local state
        get().removeParticipant(participantId);
        
        // TODO: Send kick command to backend via WebSocket
      },

      /**
       * TOGGLE PARTICIPANT AUDIO - Mute/unmute participant (host only)
       * 
       * Allows host to control participant audio state.
       * In full implementation, this would send audio control command to backend.
       */
      toggleParticipantAudio: (participantId: string) => {
        const participant = get().participants.get(participantId);
        
        if (participant) {
          console.log('🔇 Toggling audio for participant:', participantId, 'current:', participant.isAudioEnabled);
          
          get().updateParticipant(participantId, {
            isAudioEnabled: !participant.isAudioEnabled
          });
          
          // TODO: Send audio control command to backend via WebSocket
        }
      },

      /**
       * TOGGLE PARTICIPANT VIDEO - Enable/disable participant video (host only)
       * 
       * Allows host to control participant video state.
       * In full implementation, this would send video control command to backend.
       */
      toggleParticipantVideo: (participantId: string) => {
        const participant = get().participants.get(participantId);
        
        if (participant) {
          console.log('📹 Toggling video for participant:', participantId, 'current:', participant.isVideoEnabled);
          
          get().updateParticipant(participantId, {
            isVideoEnabled: !participant.isVideoEnabled
          });
          
          // TODO: Send video control command to backend via WebSocket
        }
      },

      // =================== LOCAL MEDIA CONTROLS ===================
      
      /**
       * TOGGLE AUDIO - Mute/unmute local microphone
       * 
       * Controls the user's own microphone without affecting their camera.
       * Enables/disables audio tracks in the local media stream.
       */
      toggleAudio: async () => {
        const { localStream, isAudioEnabled } = get();
        
        console.log('🎤 Toggling local audio, current state:', isAudioEnabled);
        
        if (localStream) {
          // Enable/disable all audio tracks in the local stream
          const audioTracks = localStream.getAudioTracks();
          audioTracks.forEach(track => {
            track.enabled = !isAudioEnabled;
            console.log(`🎵 Audio track ${track.enabled ? 'enabled' : 'disabled'}`);
          });
          
          // Update state to reflect new audio status
          set({ isAudioEnabled: !isAudioEnabled });
        } else {
          console.warn('⚠️ No local stream available for audio toggle');
          get().handleError('Microphone not available. Please check permissions.');
        }
      },

      /**
       * TOGGLE VIDEO - Enable/disable local camera
       * 
       * Controls the user's own camera without affecting their microphone.
       * Enables/disables video tracks in the local media stream.
       */
      toggleVideo: async () => {
        const { localStream, isVideoEnabled } = get();
        
        console.log('📹 Toggling local video, current state:', isVideoEnabled);
        
        if (localStream) {
          // Enable/disable all video tracks in the local stream
          const videoTracks = localStream.getVideoTracks();
          videoTracks.forEach(track => {
            track.enabled = !isVideoEnabled;
            console.log(`📺 Video track ${track.enabled ? 'enabled' : 'disabled'}`);
          });
          
          // Update state to reflect new video status
          set({ isVideoEnabled: !isVideoEnabled });
        } else {
          console.warn('⚠️ No local stream available for video toggle');
          get().handleError('Camera not available. Please check permissions.');
        }
      },

      /**
       * START SCREEN SHARE - Begin sharing user's screen
       * 
       * Requests screen sharing permission from browser and creates a screen capture stream.
       * Sets up automatic cleanup when user stops sharing via browser controls.
       */
      startScreenShare: async () => {
        try {
          console.log('🖥️ Starting screen share...');
          
          // Request screen sharing permission from browser
          // This will show browser's screen picker dialog
          const screenStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,    // Capture screen video
            audio: true,    // Capture system audio if available
          });

          // Set up automatic cleanup when user stops sharing
          // This triggers when user clicks "Stop sharing" in browser UI
          screenStream.getVideoTracks()[0].onended = () => {
            console.log('🛑 Screen share ended by user via browser controls');
            get().stopScreenShare();
          };

          // Update state with screen share stream
          set({ 
            screenShareStream: screenStream,
            isScreenSharing: true 
          });
          
          console.log('✅ Screen share started successfully');
          
        } catch (error) {
          console.error('💥 Failed to start screen share:', error);
          get().handleError(`Failed to start screen share: ${error}`);
        }
      },

      /**
       * STOP SCREEN SHARE - End screen sharing and clean up resources
       * 
       * Stops all tracks in the screen share stream and updates state.
       * Can be called manually or automatically when user stops sharing.
       */
      stopScreenShare: async () => {
        console.log('🛑 Stopping screen share...');
        
        const { screenShareStream } = get();
        
        // Stop all tracks in the screen share stream
        if (screenShareStream) {
          screenShareStream.getTracks().forEach(track => {
            track.stop();
            console.log(`🛑 Stopped screen share ${track.kind} track`);
          });
        }

        // Clear screen share state
        set({ 
          screenShareStream: null,
          isScreenSharing: false 
        });
        
        console.log('✅ Screen share stopped successfully');
      },

      /**
       * SWITCH CAMERA - Change to different camera device
       * 
       * Replaces the video track in the local stream with a new track from
       * the selected camera device. Maintains audio track unchanged.
       */
      switchCamera: async (deviceId: string) => {
        try {
          console.log('📹 Switching to camera device:', deviceId);
          
          // Get new video stream from selected camera
          const newStream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: deviceId } },
            audio: false, // Only get video, keep existing audio
          });

          const { localStream } = get();
          
          if (localStream) {
            // Replace video track in existing stream
            const newVideoTrack = newStream.getVideoTracks()[0];
            const oldVideoTrack = localStream.getVideoTracks()[0];
            
            // Remove old video track
            if (oldVideoTrack) {
              localStream.removeTrack(oldVideoTrack);
              oldVideoTrack.stop(); // Release old camera
              console.log('🗑️ Removed and stopped old video track');
            }
            
            // Add new video track
            if (newVideoTrack) {
              localStream.addTrack(newVideoTrack);
              console.log('➕ Added new video track from selected camera');
            }
          }
          
          // Update selected device in state
          set((state) => ({
            selectedDevices: { ...state.selectedDevices, camera: deviceId }
          }));
          
          console.log('✅ Camera switched successfully');
          
        } catch (error) {
          console.error('💥 Failed to switch camera:', error);
          get().handleError(`Failed to switch camera: ${error}`);
        }
      },

      /**
       * SWITCH MICROPHONE - Change to different microphone device
       * 
       * Replaces the audio track in the local stream with a new track from
       * the selected microphone device. Maintains video track unchanged.
       */
      switchMicrophone: async (deviceId: string) => {
        try {
          console.log('🎤 Switching to microphone device:', deviceId);
          
          // Get new audio stream from selected microphone
          const newStream = await navigator.mediaDevices.getUserMedia({
            video: false, // Only get audio, keep existing video
            audio: { deviceId: { exact: deviceId } },
          });

          const { localStream } = get();
          
          if (localStream) {
            // Replace audio track in existing stream
            const newAudioTrack = newStream.getAudioTracks()[0];
            const oldAudioTrack = localStream.getAudioTracks()[0];
            
            // Remove old audio track
            if (oldAudioTrack) {
              localStream.removeTrack(oldAudioTrack);
              oldAudioTrack.stop(); // Release old microphone
              console.log('🗑️ Removed and stopped old audio track');
            }
            
            // Add new audio track
            if (newAudioTrack) {
              localStream.addTrack(newAudioTrack);
              console.log('➕ Added new audio track from selected microphone');
            }
          }
          
          // Update selected device in state
          set((state) => ({
            selectedDevices: { ...state.selectedDevices, microphone: deviceId }
          }));
          
          console.log('✅ Microphone switched successfully');
          
        } catch (error) {
          console.error('💥 Failed to switch microphone:', error);
          get().handleError(`Failed to switch microphone: ${error}`);
        }
      },

      /**
       * REFRESH DEVICES - Update list of available media devices
       * 
       * Enumerates all available cameras, microphones, and speakers.
       * Should be called when devices are plugged/unplugged or on initial setup.
       */
      refreshDevices: async () => {
        try {
          console.log('🔄 Refreshing available media devices...');
          
          // Get all available media devices from browser
          const devices = await navigator.mediaDevices.enumerateDevices();
          
          // Filter devices by type
          const cameras = devices.filter(device => device.kind === 'videoinput');
          const microphones = devices.filter(device => device.kind === 'audioinput');
          const speakers = devices.filter(device => device.kind === 'audiooutput');

          console.log('📱 Found devices:', {
            cameras: cameras.length,
            microphones: microphones.length,
            speakers: speakers.length
          });

          // Update available devices in state
          set({
            availableDevices: { cameras, microphones, speakers }
          });
          
        } catch (error) {
          console.error('💥 Failed to refresh devices:', error);
          get().handleError(`Failed to refresh devices: ${error}`);
        }
      },

      // =================== CHAT SYSTEM ===================
      
      /**
       * SEND MESSAGE - Send chat message to room participants
       * 
       * Sends a message via WebSocket to the backend, which broadcasts it to
       * all participants in the room. Supports different message types for
       * future features like private messaging.
       */
      sendMessage: (content: string, type: 'text' | 'private' = 'text', targetId?: string) => {
        const { wsClient, clientInfo } = get();
        
        if (!wsClient || !clientInfo) {
          console.error('❌ Cannot send message: WebSocket or client info not available');
          get().handleError('Connection not ready. Please try again.');
          return;
        }

        console.log('💬 Sending message:', { content, type, targetId });
        
        // Send message via WebSocket to backend using existing sendChat method
        // Backend will broadcast to appropriate recipients based on room membership
        wsClient.sendChat(content, clientInfo);
        
        // Note: We don't add the message to local state here because
        // the backend will echo it back via 'add_chat' event, ensuring consistency
      },

      /**
       * MARK MESSAGES READ - Clear unread message count
       * 
       * Resets the unread message counter, typically called when user
       * opens the chat panel or when messages are visible.
       */
      markMessagesRead: () => {
        console.log('✅ Marking all messages as read');
        set({ unreadCount: 0 });
      },

      /**
       * TOGGLE CHAT PANEL - Show/hide chat interface
       * 
       * Controls chat panel visibility and automatically marks messages
       * as read when opening the panel.
       */
      toggleChatPanel: () => {
        set((state) => {
          const newOpen = !state.isChatPanelOpen;
          console.log(`💬 ${newOpen ? 'Opening' : 'Closing'} chat panel`);
          
          return {
            isChatPanelOpen: newOpen,
            // Clear unread count when opening chat panel
            unreadCount: newOpen ? 0 : state.unreadCount,
          };
        });
      },

      // =================== UI STATE CONTROLS ===================
      
      /**
       * TOGGLE PARTICIPANTS PANEL - Show/hide participants list
       * 
       * Controls the visibility of the participants panel which shows
       * all room members, their status, and available actions.
       */
      toggleParticipantsPanel: () => {
        set((state) => {
          const newOpen = !state.isParticipantsPanelOpen;
          console.log(`👥 ${newOpen ? 'Opening' : 'Closing'} participants panel`);
          return { isParticipantsPanelOpen: newOpen };
        });
      },

      /**
       * SET GRID LAYOUT - Change video display layout
       * 
       * Controls how participant videos are arranged on screen:
       * - gallery: Equal-sized grid of all participants
       * - speaker: Large view of active speaker with small thumbnails
       * - sidebar: Main content with sidebar of participants
       */
      setGridLayout: (layout: 'gallery' | 'speaker' | 'sidebar') => {
        console.log('🎨 Setting grid layout to:', layout);
        set({ gridLayout: layout });
      },

      /**
       * PIN PARTICIPANT - Pin participant's video prominently
       * 
       * Pins a specific participant's video to always be visible,
       * regardless of speaking status or layout changes.
       */
      pinParticipant: (participantId: string | null) => {
        console.log('📌 Pinning participant:', participantId);
        set({
          pinnedParticipantId: participantId,
          isPinned: participantId !== null,
        });
      },

      /**
       * SELECT PARTICIPANT - Select participant for actions
       * 
       * Selects a participant in the UI for performing actions like
       * private messaging, muting (if host), or viewing their details.
       */
      selectParticipant: (participantId: string | null) => {
        console.log('👆 Selecting participant:', participantId);
        set({ selectedParticipantId: participantId });
      },

      // =================== CONNECTION MANAGEMENT ===================
      
      /**
       * UPDATE CONNECTION STATE - Update connection status for UI
       * 
       * Updates connection indicators shown to users, enabling real-time
       * feedback about WebSocket and WebRTC connection health.
       */
      updateConnectionState: (updates: Partial<ConnectionState>) => {
        console.log('🔗 Updating connection state:', updates);
        set((state) => ({
          connectionState: { ...state.connectionState, ...updates }
        }));
      },

      /**
       * HANDLE ERROR - Display error message to user
       * 
       * Stores error messages for display in the UI, providing users
       * with feedback about what went wrong and how to resolve issues.
       */
      handleError: (error: string) => {
        console.error('❌ Room error:', error);
        set((state) => ({
          connectionState: { ...state.connectionState, lastError: error }
        }));
      },

      /**
       * CLEAR ERROR - Remove current error message
       * 
       * Clears the current error message, typically called when user
       * dismisses error notifications or when error condition resolves.
       */
      clearError: () => {
        console.log('🧹 Clearing error message');
        set((state) => ({
          connectionState: { ...state.connectionState, lastError: undefined }
        }));
      },
    }),
    {
      name: 'room-store', // Name shown in Redux DevTools
    }
  )
);

// =================== USAGE DOCUMENTATION ===================

/**
 * STORE USAGE EXAMPLES
 * 
 * This store is designed to be used throughout the video conference application.
 * Here are common usage patterns:
 * 
 * // Initialize and join a room
 * const { initializeRoom, joinRoom } = useRoomStore();
 * await initializeRoom('room-123', 'John Doe', 'jwt-token-here');
 * await joinRoom();
 * 
 * // Control local media
 * const { toggleAudio, toggleVideo, startScreenShare } = useRoomStore();
 * await toggleAudio();        // Mute/unmute microphone
 * await toggleVideo();        // Enable/disable camera
 * await startScreenShare();   // Start sharing screen
 * 
 * // Send chat messages
 * const { sendMessage } = useRoomStore();
 * sendMessage('Hello everyone!');
 * 
 * // Access state in React components
 * const { participants, messages, isHost, connectionState } = useRoomStore();
 * 
 * // Subscribe to specific state changes
 * const isConnected = useRoomStore(state => state.connectionState.wsConnected);
 * const participantCount = useRoomStore(state => state.participants.size);
 * 
 * // Clean up when done
 * const { leaveRoom } = useRoomStore();
 * leaveRoom(); // Stops all media, disconnects WebSocket, resets state
 * 
 * INTEGRATION POINTS:
 * 
 * 1. Room Page Component (/app/(room)/[roomid]/page.tsx):
 *    - Calls initializeRoom() on mount with room ID from URL
 *    - Calls leaveRoom() on unmount or navigation away
 * 
 * 2. Video Grid Component (/components/layout/video-grid.tsx):
 *    - Subscribes to participants map for rendering video tiles
 *    - Uses gridLayout state for display arrangement
 *    - Shows pinned participant prominently
 * 
 * 3. Control Bar Component (/components/layout/control-bar.tsx):
 *    - Uses media control actions (toggleAudio, toggleVideo, etc.)
 *    - Shows connection state indicators
 *    - Provides UI for leaving room
 * 
 * 4. Chat Panel Component (/components/panels/chat-panel.tsx):
 *    - Subscribes to messages array and unreadCount
 *    - Uses sendMessage action for sending chat
 *    - Calls markMessagesRead when panel is visible
 * 
 * 5. Participants Panel Component (/components/panels/participants-panel.tsx):
 *    - Subscribes to participants map and pendingParticipants
 *    - Uses participant management actions (kick, approve, etc.) if host
 *    - Shows participant status and controls
 * 
 * ERROR HANDLING:
 * 
 * The store includes comprehensive error handling:
 * - Connection failures trigger automatic reconnection
 * - Media permission denials show user-friendly messages
 * - Invalid actions are logged and ignored gracefully
 * - All errors are stored in connectionState.lastError for UI display
 * 
 * PERFORMANCE CONSIDERATIONS:
 * 
 * - State updates are batched where possible to minimize re-renders
 * - Large collections (participants, messages) use efficient data structures
 * - Media streams are properly cleaned up to prevent memory leaks
 * - Event handlers are cleaned up when leaving rooms
 * 
 * TESTING:
 * 
 * The store is designed to be easily testable:
 * - All actions are synchronous except where noted
 * - State mutations are pure and predictable
 * - WebSocket and WebRTC dependencies are injected, enabling mocking
 * - Comprehensive logging facilitates debugging
 */
